### puzzle

#### A\*算法 寻找N\*N拼图的解

算法核心：

1. 遍历所有未扩展节点opens，选择估值最小节点，并将其从opens中移除，添加到已扩展节点closeMap中
2. 判断该节点是否是最终节点，如果是目标节点，结束循环；如果不是则扩展节点
3. 对扩展所有节点进行判断，是否已经存在已扩展节点closeMap中，如果已经扩展过，则舍去该扩展节点；如果该节点没有扩展，则判断其在opens中是否存在，如果在opens中并不存在，则添加到opens中，如果在opens中存在，则判断两者估值大小，保留估值小的
4. 重复步骤1

估值函数：   f(n)=g(n)+h(n)  （我这里更加追求寻找效率，不需要最优解）

1. h(n)为步数相关函数，我这里使用 h(n) = x，即步数和h(n)成1：1的线性关系，当h(n)为0时，其退化成深度优先搜索
2.  g(n)越小搜索范围越广，越能找到最优解，g(n) 等于0时，即为广度优先搜索；g(n)越大效率越高，我这里使用了g(n)=（所有节点到目标节点的距离和）\* N \* N；



待优化问题： 5*5拼图是我笔记本的极限，需要进一步优化算法或者采用其它更有效率的算法


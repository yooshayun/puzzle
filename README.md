### puzzle

#### A\*算法 复杂度O（n^2） 寻找N\*N拼图的解

#### 文件/puzzle.html

算法核心：

1. 遍历所有未扩展节点opens，选择估值最小节点，并将其从opens中移除，添加到已扩展节点closeMap中
2. 判断该节点是否是最终节点，如果是目标节点，结束循环；如果不是则扩展节点
3. 对扩展所有节点进行判断，是否已经存在已扩展节点closeMap中，如果已经扩展过，则舍去该扩展节点；如果该节点没有扩展，则判断其在opens中是否存在，如果在opens中并不存在，则添加到opens中，如果在opens中存在，则判断两者估值大小，保留估值小的
4. 重复步骤1

估值函数：f(n)=g(n)+h(n)  （我这里更加追求寻找效率，不需要最优解）

1. h(n)为步数相关函数，我这里使用 h(n) = x，即步数和h(n)成1：1的线性关系，当h(n)为0时，其退化成深度优先搜索
2.  g(n)越小搜索范围越广，越能找到最优解，g(n) 等于0时，即为广度优先搜索；g(n)越大效率越高，我这里使用了g(n)=（所有节点到目标节点的距离和）\* N \* N；



关于拼图打乱后是否可以还原（N\*N数码问题）

> 先将N\*N拼图的状态表示成一维的形式，求出除空白之外所有数字的逆序数之和，也就是每个数字前面比它大的数字的个数的和，称为这个状态的逆序。

1. N为奇数时，若两个状态的逆序奇偶性相同，则可相互到达，否则不可相互到达。
2.  N为偶数时，空格每上下移动一次，奇偶性改变。称空格位置所在的行到目标空格所在的行步数为空格的距离（不计左右距离），若两个状态的可相互到达，则有，两个状态的逆序奇偶性相同且空格距离为偶数，或者，逆序奇偶性不同且空格距离为奇数数。否则不能。 


待优化问题： 5*5拼图是我笔记本的极限，需要进一步优化算法或者采用其它更有效率的算法

